# Огляд проекту: Beauty Salon Manager

**Останнє оновлення:** 8 травня 2025, 19:15 EEST

## 1. Загальна інформація

- **Назва:** Beauty Salon Manager
- **Опис:** Веб-додаток для управління записами, клієнтами, послугами та персоналом салону краси.
- **Статус:** В розробці
- **Розгорнуто на:** PythonAnywhere
- **URL (PythonAnywhere):** https://mil2212.pythonanywhere.com/
- **Репозиторій GitHub:** https://github.com/Efm-ua/beauty-salon-manager

## 2. Технологічний стек

- **Мова:** Python (3.13.1 (з локального venv))
- **Фреймворк:** Flask (3.1.0)
- **ORM:** SQLAlchemy (2.0.38)
- **База даних:** SQLite
  - **Розташування (локально):** `instance/beauty_salon.db`
  - **Розташування (PythonAnywhere):** `/home/mil2212/beauty-salon-manager/instance/beauty_salon.db`
- **Міграції БД:** Flask-Migrate / Alembic (Flask-Migrate: 4.1.0, Alembic: 1.15.2)
  - **Поточна ревізія БД (HEAD):** `65f9ff3f0dfd`
- **Форми:** Flask-WTF (1.2.2)
- **Автентифікація:** Flask-Login (0.6.3)
- **Шаблонізатор:** Jinja2 (3.1.6)
- **Фронтенд:** HTML, CSS (Bootstrap 5.3.0-alpha1), JavaScript
- **Тестування:** Pytest (8.3.5)
  - Плагіни: pytest-flask (1.3.0), pytest-cov (6.1.1), pytest-mock (3.14.0)
- **Якість коду:**
  - Black (25.1.0)
  - isort (6.0.1)
  - flake8 (7.2.0)
  - mypy (1.15.0)
- **Залежності (основні):**
  - Flask==3.1.0
  - SQLAlchemy==2.0.38
  - Flask-Migrate==4.1.0
  - Flask-Login==0.6.3
  - Flask-WTF==1.2.2
  - pytest==8.3.5
  - python-dotenv==1.0.1
- **Середовище розробки:** Windows (PowerShell)
- **Віртуальне середовище (локально):** `venv` в корені проекту.
- **Віртуальне середовище (PythonAnywhere):** `/home/mil2212/venv_app`

## 2.1. Рекомендації для Міграцій Бази Даних (SQLite)

### Проблема з `op.batch_alter_table()` в SQLite

SQLite має обмежену підтримку операцій `ALTER TABLE`, тому Alembic використовує "batch mode" для операцій, які не підтримуються напряму (наприклад, видалення колонки, зміна типу з обмеженнями). Цей режим включає створення тимчасової таблиці, копіювання даних, видалення старої таблиці та перейменування нової. Це може викликати проблеми з зовнішніми ключами (FOREIGN KEY constraints).

### Рекомендація щодо `PRAGMA foreign_keys=OFF`

При створенні нового файлу міграції, якщо він містить операції `op.batch_alter_table()` або інші складні зміни схеми, **проактивно** додавайте на початок функцій `upgrade()` та `downgrade()` код для тимчасового вимкнення перевірки зовнішніх ключів:

```python
# На початку файлу міграції додати:
from sqlalchemy import text
from alembic import op
import sqlalchemy as sa

def upgrade():
    bind = op.get_bind()
    if bind.engine.name == 'sqlite':
        bind.execute(text('PRAGMA foreign_keys=OFF'))
    
    # ... тіло функції upgrade ...

def downgrade():
    bind = op.get_bind()
    if bind.engine.name == 'sqlite':
        bind.execute(text('PRAGMA foreign_keys=OFF'))
    
    # ... тіло функції downgrade ...
```

**Примітка:** `PRAGMA foreign_keys=ON` явно в кінці функцій зазвичай не потрібен, оскільки Alembic виконує міграції в транзакції, і налаштування PRAGMA скидається після завершення транзакції.

### Умовне Видалення Таблиць (`DROP TABLE IF EXISTS`)

Якщо міграція має видаляти таблицю, яка могла бути не створена або видалена раніше (наприклад, тимчасові таблиці Alembic або таблиці, що перестворюються), рекомендується використовувати умовне видалення, щоб уникнути помилки "no such table":

```python
import sqlalchemy as sa
from alembic import op

def upgrade():
    bind = op.get_bind()
    inspector = sa.inspect(bind)
    existing_tables = inspector.get_table_names()
    
    if "my_table_to_drop" in existing_tables:
        op.drop_table("my_table_to_drop")
```

### Команда `flask db stamp`

`flask db stamp <revision_id>` дозволяє позначити міграцію як застосовану без фактичного виконання її SQL команд. Це може бути корисним, якщо таблиці/колонки вже існують (наприклад, після частково невдалої попередньої міграції), і їх структура відповідає очікуваній.

**Використовувати з обережністю після перевірки схеми.**

### Важливість Тестування Міграцій

Завжди тестуйте міграції у локальному середовищі, максимально наближеному до production (з використанням SQLite), перед застосуванням на робочому сервері. Це допоможе виявити потенційні проблеми з зовнішніми ключами, конфліктами таблиць та іншими SQLite-специфічними особливостями.

## 3. Структура проекту

- **`app/`**: Основний код додатку
  - **`__init__.py`**: Фабрика додатку (`create_app`)
  - **`config.py`**: Класи конфігурації
  - **`models/__init__.py`**: Моделі SQLAlchemy
  - **`routes/`**: Маршрути Flask (Blueprints: `auth.py`, `main.py`, `appointments.py`, `clients.py`, `services.py`, `reports.py`)
  - **`static/`**: Статичні файли
  - **`templates/`**: Шаблони Jinja2
  - **`commands.py`**: Кастомні CLI команди Flask (`create-admin`) - _Перевірити наявність та актуальність_
- **`migrations/`**: Файли міграцій Alembic
  - **`versions/`**: Скрипти міграцій
- **`tests/`**: Тести Pytest
  - **`conftest.py`**: Фікстури та конфігурація тестів
  - `unit/`, `integration/`, `functional/`
- **`instance/`**: Конфігураційні файли, БД SQLite (`beauty_salon.db`) (Не в Git)
- **`run.py`**: Точка входу для локального запуску.
- **`requirements.txt`**: Залежності Python.
- **`.env`**: Змінні середовища.
- **`.gitignore`**: Правила Git.
- **`wsgi.py` (PythonAnywhere):** `/var/www/mil2212_pythonanywhere_com_wsgi.py` (Поза репозиторієм).

## 4. Ключові компоненти та логіка

- **Автентифікація:** Flask-Login, модель `User`. Ролі: `is_admin` (boolean), `is_active_master` (boolean). Користувач є або адміністратором, або майстром (визначається `not User.is_admin`). Поле `schedule_display_order` (Integer, nullable=True, default=999) використовується для сортування активних майстрів у розкладі. Поле `configurable_commission_rate` (Float, nullable=True) для налаштування індивідуальних комісійних ставок.
- **Записи (Appointments):** Модель `Appointment`, зв'язок з `Client`, `User` (майстер), `Service` (M2M через `AppointmentServiceLink`). Інтеграція з продажами товарів - відображення проданих товарів у деталях запису, автоматичне оновлення загальної суми запису.
- **Клієнти (Clients):** Модель `Client`.
- **Послуги (Services):** Модель `Service`.
- **Майстри (Masters):** Модель `User` з `is_active_master=True`.
- **Ціноутворення:** Динамічне (`get_total_price`, `get_discounted_price` в моделі `Appointment`).

### Товарний Облік та Склад
- **Моделі:** `Brand`, `Product` (з авто-генерацією SKU, об'ємом, ціною продажу, собівартістю останньої партії), `StockLevel` (автоматичне створення при додаванні товару, відстеження поточної кількості).
- **Надходження товарів:** Моделі `GoodsReceipt`, `GoodsReceiptItem`. Функціонал для оприбуткування товарів (введення кількості та ціни закупівлі), що оновлює `StockLevel` та `Product.last_cost_price`. UI для створення та перегляду документів надходження.

### Продажі Товарів
- **Моделі:** `PaymentMethod` (реалізовано як таблиця в БД), `Sale`, `SaleItem`.
- **Логіка:** Облік продажів, автоматичне списання товарів зі складу за методом FIFO, розрахунок та збереження собівартості проданої одиниці (`SaleItem.cost_price_per_unit`) для подальшого аналізу COGS.
- **Інтерфейс:** Форми та сторінки для створення нового продажу (з динамічним додаванням товарів та розрахунком суми "на льоту"), перегляду списку продажів та деталей конкретного продажу.
- **Інтеграція з Записами на Послуги:** Можливість пов'язати продаж із записом, відображення проданих товарів у деталях запису, автоматичне оновлення загальної суми запису.

### Списання Товарів
- **Моделі:** `WriteOffReason` (з можливістю CRUD та управлінням статусом `is_active`), `ProductWriteOff`, `ProductWriteOffItem`.
- **Логіка:** Списання товарів зі складу за методом FIFO для коректного обліку собівартості списаного. Оновлення `StockLevel`. UI для створення та перегляду документів списання.

### Інвентаризація Товарів
- **Моделі:** `InventoryAct`, `InventoryActItem`.
- **Логіка:** Створення акту інвентаризації (з автоматичним заповненням очікуваної кількості з `StockLevel`), введення фактичної кількості, розрахунок розбіжностей. "Проведення" акту з оновленням `StockLevel` відповідно до фактичних залишків. UI для створення, редагування, проведення та перегляду актів.

### Комісії та Зарплати (Оновлено)
- **Звіт по зарплаті майстрів:** Розрахунок комісії від наданих послуг (на основі `User.configurable_commission_rate`) та фіксованої 9% комісії від проданих майстром товарів. Фільтрація за періодом.
- **Звіт по зарплаті адміністратора:** Розраховує зарплату на основі комісії від особисто наданих послуг, комісії від особисто проданих товарів (`configurable_commission_rate` + 1%) та 1% частки від продажів товарів, здійснених усіма майстрами. Фільтрація за періодом.

- **Звіти (Reports):** Фінансовий (оновлено з інтеграцією даних про продажі товарів: дохід від товарів, COGS за FIFO, валовий прибуток від товарів), Зарплатний (розширено для майстрів та адміністраторів).
- **CLI команди:** `flask create-admin`, `flask create-payment-methods`. (Перевірити `app/commands.py` на інші команди).
- **Управління майстрами:** Адміністратори можуть керувати статусом `is_active_master`, порядком `schedule_display_order` та індивідуальними комісійними ставками (`configurable_commission_rate`) для майстрів через інтерфейс редагування користувачів у auth blueprint (шлях /auth/users/<id>/edit).

## 5. Розгортання та оточення

- **Платформа:** PythonAnywhere (Тип акаунту:Paid)
- **База даних:** SQLite (`instance/beauty_salon.db`).
- **Оновлення коду:** GitHub webhook.
- **WSGI сервер:** Налаштовано PythonAnywhere.
- **Залежності PythonAnywhere:** Синхронізуються з `requirements.txt` в `/home/mil2212/venv_app`.
- **Міграції на PythonAnywhere:** Ручний запуск `flask db upgrade` в консолі PA.

## 6. Процес розробки та тестування

- **Контроль версій:** Git / GitHub.
- **Гілки:** `* main` (локальна)
- **Тестування:** Pytest (локально). CI/CD: Не виявлено (директорія `.github/workflows/` відсутня)
- **Якість коду:** Black, isort, flake8, mypy (перед комітами).
- **Менторство:** AI-ментор (Gemini) + Cursor AI.

## 7. Поточні завдання / Проблеми



## 8. Додаткові нотатки / Контекст

- Історія міграція (2ea257154bf4 (head)).
